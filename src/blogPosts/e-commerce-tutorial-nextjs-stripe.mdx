---
slug: "blog/e-commerce-tutorial-nextjs-stripe"
title: "Build an E-commerce Website with Webiny Serverless Headless CMS, Next.js, and Stripe"
description: "In this tutorial, we'll create an e-commerce website using Webiny Serverless Headless CMS, Next.js, and Stripe."
tags: ["Serverless", "Web development", "Javascript", "Software Development", "GraphQL"]
featureImage: "./assets/e-commerce-tutorial-nextjs-stripe/e-commerce-tutorial-nextjs-stripe-cover.png"
author: albiona
date: 2020-10-19
---

In this tutorial we will create a simple e-commerce website, where you can buy Swag from the best Open Source Projects such as Webiny, Next.js, React, etc.

Before we continue, let's go through what you'll learn on building this website.

You will learn how to create the back-end with <ExternalLink href="http://docs.webiny.com/docs/webiny-apps/headless-cms/features/content-modeling?utm_source=Webiny-blog&utm_medium=webiny-headless-cms-features-docs&utm_campaign=webiny-blog-e-commerce-tutorial-oct-19&utm_content=webiny-headless-cms-features-docs&utm_term=W00180">Webiny Headless CMS</ExternalLink>
with two content models, the products, and the categories.
Then, fetching the data from the headless CMS to the Next.js project using Apollo GraphQL.
Last but not least, integrating Stripe to implement a shopping cart for our products.

While working on this starter, I shared my progress on Twitter and <ExternalLink href="https://twitter.com/joshuaackerman">Josh</ExternalLink> from Stripe <ExternalLink href="https://twitter.com/joshuaackerman/status/1305857426059653122?s=20">reached out</ExternalLink> for being available for any feedback regarding improvements, developer experience and documentation,
thank you, Josh!

Without further ado let's get started.

![e-commerce gif](./assets/e-commerce-tutorial-nextjs-stripe/e-commerce-2.gif)

TLDR; <ExternalLink href="http://www.github.com/webiny/webiny-examples">Get the code here</ExternalLink>

## 1. The e-commerce-starter

To get started, we'll clone the `e-commerce-starter` git repository.
The starter will have a ready-made Next.js application, and the Ant Design UI Library set up
that looks like in the image below.

![E commerce starter](/assets/e-commerce-tutorial-nextjs-stripe/e-commerce-starter.png)

We already have some components and functionalities ready, such as the `Header`, `Search`, `Product List`, the `Product` card, and the `Cart` component.

Clone the `e-commerce-starter` project by running the following commands to have the project set up and running.

```
  git clone https://github.com/AlbionaHoti/e-commerce-start // will update the link
  cd e-commerce-start
  npm install
  npm run dev

  // head over to localhost:3000
```

Now that we have the starter project, we can focus on creating the back-end with Webiny headless CMS and fetching the data to our front-end.

## 2. Webiny Headless CMS

Webiny provides several serverless websites such as the Headless CMS, Page Builder, Form Builder and File Manager.
In this tutorial, we are going to use the Headless CMS only.

### Prerequisites

- A Webiny Headless CMS Project

  First of all, make sure you have a working <ExternalLink href="http://docs.webiny.com/docs/get-started/quick-start">Webiny project</ExternalLink> set up.

> When setting up a new project, currently, there are two project templates you
> can choose from: `full` and `cms`. Both include the Headless CMS app by default.

- Content Delivery API URL

  The Headless CMS app exposes data via the `Content Delivery API`,
  which is a simple GraphQL API that dynamically updates its schema on
  content model changes that you make. Once you have deployed your API stack
  (using the `yarn webiny deploy api --env=local` command), you should be able to
  find the Content Delivery API URL in the `API Information` menu item, in your admin app.

- Content Delivery API Access Token

  In order to access the data via the Content Delivery API, we'll need a valid Access Token.

  1.  Follow the <ExternalLink href="http://docs.webiny.com/docs/webiny-apps/headless-cms/features/access-tokens/">link</ExternalLink> here to create an access token for a specific environment.
  2.  Use this access token as a HTTP header to your GraphQL Playground in `/cms/read/{alias}` endpoints.
      ![Access token auth](/assets/e-commerce-tutorial-nextjs-stripe/access-tokens-graphql.png)

  > In the root of the `e-commerce-starter` app that you set up,
  > you will find the `.env` file, that's the place where we need to save the Content Delivery API, and the Content Delivery API Access Token

Now that we have all of the prerequisites out of the way, it's time to create our first content model for the e-commerce website.

We are going to create two content models, the `products` and `category`

- Products
  - 6 Created Products
- Category
  - 3 Created Categories

Let's go through the images below and create the content models for products and categories.

The `Products` content model.

![Products content model](/assets/e-commerce-tutorial-nextjs-stripe/products_content_model.png)

The `Products` content model, will contain the fields as shown in the image:

- Title - `Text`
- Image - `Files`
- Price - `Number`
- Description - `Long text`
- Permalink - `Text`, and
- Category - `Reference(multiple values)`.

When adding a `Reference field`, you can toggle the `Use as a list of references` switch in field settings, to do a multi-select. In this case, a product can have multiple categories.

![Products Ref Field](/assets/e-commerce-tutorial-nextjs-stripe/products_ref_field.png)

The `Category` content model.

![Category content model](/assets/e-commerce-tutorial-nextjs-stripe/category_content_model.png)

The `Category` content model will contain the fields such as:

- Title - `Text(entry title)`
- Products - `Reference(multiple values)`

We toggle the `Use as a list of references` for the category can have multiple Products.

Now that we have created the content models, click on View Content and start creating your Swag products and the categories üéâ

## 3. Next.js + Apollo GraphQL to fetch data from the backend

We are going to start off by installing a few NPM packages:

- `@apollo/client` - This single package contains virtually everything we need to set up Apollo Client. It includes the in-memory cache, local state management, error handling, and a React-based view layer.

- `graphql` - This package provides logic for parsing GraphQL queries.

```
npm i @apollo/client graphql --save
```

Now that we installed the necessary packages, lets check the e-commerce-starter website structure in the image below:

![E commerce starter structure](/assets/e-commerce-tutorial-nextjs-stripe/e-commerce-starter-structure.png)

- `/components` folder contains the react antd starter components, as seen in the image above.
- `/context/context.js` contains the React context that holds the state of the `Cart`, `Favorite` products, `Modal` of Products Cart, and `Total` price of the cart.
- `/pages/_app.js` component file is provided by Next.js, and serves as a wrapper of every single Next.js page of your front-end.
  The `_app.js` file allows us to wrap the `Apollo Provider` around the function component so that we can have it available in every single page.

Now, you may ask What is Apollo Provider‚ÅâÔ∏è Good point ‚ÄºÔ∏è

---

Now that we have covered the packages used and the folder structure of our `e-commerce-starter` app, let's jump on the code.

Open the `_app.js` file and paste the following snippet:

`gist:AlbionaHoti/22688a0c4fac917a17f3ddaec13fc9b5`

Now that we've seen what the `_app.js` is made of, lets dig into the actual GraphQL client file.

Go ahead in the root of the project, and create the `lib/apolloClient.js` file, and paste the following snippet:

`gist:AlbionaHoti/3d251625b1665f06c05cc7d6d643764b`

The one important bit of the above snippet is the new instance of `ApolloClient`
which has some options such as the `link` ‚Üí this is the part where we
tell the Apollo how to go and fetch the data, and we do that by calling a new instance of `HttpLink`,
and pass the options to this, which is the `uri` ‚Üí That means: `Where on the internet does your GraphQL URL exists?` üöÄ
This is where the Webinys Content Delivery API Url comes into play.

We noted on the Webiny Headless CMS section: `In order to access the data via the Content Delivery API, we'll need a valid` <ExternalLink href="http://docs.webiny.com/docs/webiny-apps/headless-cms/features/access-tokens/">Access Token</ExternalLink>

So, in the headers, we pass the `authorization` with our Access Token.

Now, finally we are going to start fetching the actual content from our headless CMS back-end project. üöÄüöÄ

With this set-up, now we have the `apolloClient` that is passed to the `ApolloProvider` in
the `_app.js` file, for the `ApolloProvider` wraps every single page within our application,
we can actually go into a page, and import a hook called `useQuery` and the `gql`.
With these two, we can perform queries against our GraphQL API. Let's do that!

Navigate to the `components/ProductList.js` file, and paste the below snippet:

`gist:AlbionaHoti/6de0c012c0041e883f34be3a40db50b9`

We've defined our `QUERY`, now we will use the query with the `useQuery` hook, which will return the `data`, the `error`, and a boolean `loading`,
for whether it's still loading the data.

When we get the data from the headless CMS, we are implementing a simple `search` functionality for the products.
We receive the `search` value through the `props` of the `ProductList` component.

Before jumping on the `localhost:3000/` to see the actual data, we need to add one more detail!

> Next.js provides different methods for fetching data, one of them is `getStaticProps` - this method allows you to update existing pages by re-rendering them in the background as traffic comes in.

Navigate to the `pages/index.js` file, and paste the following snippet:

`gist:AlbionaHoti/d1941660f432658116dfc87d330c8d61`

The `getStaticProps` function gets called at build time on server-side.
It won't be called on client-side, so you can even do direct database queries.

Inside this function, we are querying our GraphQL API, and cashing the data in the background. Now, you can freely update your content on the Webiny headless CMS üéâ

Now that we have the data, let's go and check the `ProductCard` component that came
with the `e-commerce-starter` pack üöÄ Navigate to the `components/Product.js` file,
there you'll find the product cart functionalities such as `addToCart`,
`removeFromCart`, and `addToFavorites`. One functionality is missing though,
and that is the `goToProduct` that should open a modal, and show the product details‚ÅâÔ∏è

> <ExternalLink href="https://www.webiny.com/blog/webiny-hacktoberfest-2020">
>   Webiny Hacktoberfest 2020{" "}
> </ExternalLink>

You can freely open a PR for the `goToProduct` function and make it your first PR @ <ExternalLink href="https://www.webiny.com/">Webiny</ExternalLink>. üë©üèª‚ÄçüöÄ

## 4. Next.js + Stripe to create the payment intents

In this tutorial we will use the <ExternalLink href="https://stripe.com/docs/payments/payment-intents">Stripe Payment Intents</ExternalLink> API with Next.js and follow best practices as set out by Stripe and the industry.

We already have pre-build components such as the `CheckoutForm.js` in our `e-commerce-starter` app,
the two components that aren't finished and we will be finishing them in this tutorial, are the
`CheckoutForm.js` and the `Layout.js` components.

The `CheckoutForm.js` component has the `billingDetails` and an empty spot for the `CardElement`
we are going to add together, it has a submit button and a spot to display some errors. Check out the `CheckoutForm.js` below:

`gist:AlbionaHoti/b3efdb52196d42113b130dace41159f2`

The `Layout.js` component, you can think of this component as a wrapper around all of our pages in the site. In here we will going to load the `stripe.js`.

Check out the `Layout.js` component below:

`gist:AlbionaHoti/c4233096fe3eee54833ddbd73578d96e`

---

One last check regarding the stripe integration before we can start coding,
is that we need to go at the root of `e-commerce-starter` project and add two variables on `.env`file:

```
PUBLISHABLE_KEY=pk_test_1234
SECRET_KEY=sk_test_1234
```

The publishable and the secret key can be found in the Stripe dashboard,
make sure to sign up for a Stripe account if you didn't already, and navigate to the <ExternalLink href="https://dashboard.stripe.com/test/apikeys">Stripe Dashboard</ExternalLink> - make
sure that you are `Viewing test data`, if not, toggle it `on`. Click on `Developers` and on the `API keys` as shown in the image below.

![Stripe Dashboard](/assets/e-commerce-tutorial-nextjs-stripe/stripe-dashboard.png)

Now, copy the `keys` to the `.env` file, and run the `e-commerce-starter` project by running the `npm run dev` command,
and the project will be served in the `localhost:3000`:

![Checkout form page](/assets/e-commerce-tutorial-nextjs-stripe/checkout-page.png)

When clicking on the cart, and proceed to do the payment, this is the view we will get in `/checkout` page.
Here we have the checkout view, to proceed with the payment üöÄ

Let's go and add the `Pay` functionality!

---

Install the packages listed below:

```jsx
npm install stripe @stripe/stripe-js @stripe/react-stripe-js axios --save
```

Now, head back to the code editor and open the `component/Layout.js` file and add these changes:

```jsx
import { loadStripe } from "@stripe/stripe-js";
import { Elements } from "@stripe/react-stripe-js";

const stripePromise = loadStripe(`${process.env.PUBLISHABLE_KEY}`);
```

Now, we have a stripe promise which resolves to stripe.js, we have to find a way to
inject that stripe.js object into the rest of our Next.js components.

To do that, we will use the `Elements` provider from `react-stripe-js` library, and wrap the
`{props.children}` of each of our pages in the Elements provider:

```jsx
<Elements stripe={stripePromise}>{props.children}</Elements>
```

Lets do a quick check if it's everything working on `localhost:3000`!

The project should compile without any errors.

Here is the full view of the `components/Layout.js` file:

`gist:AlbionaHoti/5c07c415d6bedfd6bc910bcd0ec64f3a`

One thing is still missing, and that is the Card Input, lets add it right now üôÇ

Navigate to the `components/CheckoutForm.js` file and import the Card Element like so:

```jsx
import { CardElement } from "@stripe/react-stripe-js";
```

Now, add the `CardElement` to the `CardElementContainer`

```jsx
<CardElementContainer>
  <CardElement />
</CardElementContainer>
```

You should see now a Card input! Lets go and change the styles of the Card
input by adding the `options` prop to the `CardElement` and passing there
the `cardElementOpts` variable that was pre-build with the `e-commerce-starter`.

Whoa! üöÄNow that we have the Card input set-up, one thing is missing and
that is the payment, we are not able to accept payments yet.

Head over to `components/CheckoutForm.js` to continue adding the payment functionality.

**The steps we will do are:**

- 1. Create a payment intent on the server
  - One call to the stripe node library, to get the client_secret of that payment intent
- 2. Create a payment method
  - To create a payment method, we will need a reference of stripe.js object which has the function to create the `payment method`
  - When we create the `payment method` we will need a reference to the CardElement that we defined earlier.
- 3. Confirm the card payment

  - We will combine the `payment method` id, and use the `client_secret` that we'll get in the first step.

- 1. Create a payment intent on the server

Now, we will use `axios` to make a `post` request to our backend.

```jsx
const { data: clientSecret } = await axios.post("/payment_intents", {
  amount: totalPrice * 100,
});

console.log("clientSecret:", clientSecret);
```

The `totalPrice` we are getting is from the `total` context, that holds the total
price of all the products that are on the `Cart`. Whenever the price changes,
it will end up into the `total` context and triple down into our component `CheckoutForm.js`.

Now, lets check what is happening on the server side, navigate to `pages/api/payment_intents.js`,
and see what's happening. Check out the code snipped below:

`gist:AlbionaHoti/40a44f90354b16380515360ffd1c5b1b`

As you can see, for the `/payment_intents` endpoint, we have a simple handler.
We extract the `amount` from the request body, we make a request to `stripe.paymentIntents.create`
sending the `amount` and the `currency`, and we return back the payment intents client secret.

Now, go back to Chrome and see what happens when we have the credit card number in the input üöÄ
In the console tab of developer tools, if there are no errors, you'll see the `clientSecret` logged.

We will be using the `clientSecret` to confirm the card payment once we create the payment method!

- 2. Create a payment method

To create the payment method, we will add another function under the axios request, as seen in the snippet below:

```jsx
import { CardElement, useStripe, useElements } from "@stripe/react-stripe-js";

// Add the reference to the elements object, using the useElements() hook
// and the reference to the stripe object, using the useStripe() hook

const CheckoutForm = () => {
  const stripe = useStripe();
  const elements = useElements();

  const handleSubmit = async e => {
    //...
    const cardElement = elements.getElement(CardElement);

    // create the payment method:
    const paymentMethodReq = await stripe.createPaymentMethod({
      type: "card",
      card: cardElement,
      billing_details: billingDetails,
    });

    console.log("paymentMethodReq: ", paymentMethodReq);
    //...
  };
};
```

What we are doing here is that we provide the `billingDetails`, we have from our checkout form, the `cardElement` and the
type of method which in this case its `card`.

Now lets head over to chrome and test üôÇ

![Payment method req](/assets/e-commerce-tutorial-nextjs-stripe/payment_method_req.png)

This is what we'll get from the `paymentMethodReq`, it resolved to a paymentMethod object which
has a `paymentMethod` `id` which we'll be going to use to confirm the card payment üéâ

- 3. Confirm the card payment

Now, we'll confirm the card payment by using the `confirmCardPayment` stripe method, add the following snippet on `CheckoutForm.js` file:

```jsx
const confirmCardPayment = await stripe.confirmCardPayment(clientSecret, {
  payment_method: paymentMethodReq.paymentMethod.id,
});

console.log("confirmCardPayment: ", confirmCardPayment);
```

Now, go ahead at `localhost:3000` and add some products to the cart, and hit pay, check on the console log to find the below result:

![Payment intent](/assets/e-commerce-tutorial-nextjs-stripe/payment_intent.png)

We got the `paymentIntent` id, and the `status` which is `succeeded`.

So far, we successfully created a functional payments integration with Stripe üéâ

Check out the below snippet, to get the full code for the `CheckoutForm.js` file:

`gist:/AlbionaHoti/1c3a724ce96a1e63177a2e8cbbc490e2`

# Conclusion

![https://media.giphy.com/media/TdfyKrN7HGTIY/giphy.gif](https://media.giphy.com/media/TdfyKrN7HGTIY/giphy.gif)
